# Output from selections, in columns 8-12
column(5,
# Plot graph
shinycssloaders::withSpinner(plotOutput("plot")))
)
), # End of Application Sub-tab
# Second side-panel navigational tab (User's Guide)
tabPanel("User's Guide",
includeMarkdown("StaticPosts/UserGuide.Rmd")
), # End of How-To Sub-tab
# Third side-panel navigational tab (Meta Data)
tabPanel("About the Data",
h4(p("Coming Soon"))
), # End of Meta sub-tab
# Set side-panel width (2) and Nav list panel (10) widths using fluid grid system
fluid = TRUE, widths = c(2,10))), # End of Data Explorer tab
# Lake Characteristics navigational (expandable) tab----
navbarMenu("Lake Characteristics", icon = icon("water"),
# Options beneath "Lake Characteristics"
tabPanel("Lake Ontario",
includeMarkdown("StaticPosts/LakeOntario-About.Rmd")
),
tabPanel("Oneida Lake",
includeMarkdown("StaticPosts/OneidaLake-About.Rmd")
),
tabPanel("Onondaga Lake",
h4(p("Coming Soon"))
)
), # End of Lake Characteristics tab
# Topics navigational (expandable) tab----
navbarMenu("Topics", icon = icon("lightbulb"),
# Options beneath "Topics"
tabPanel("Great Lakes Geomorphology",
# Read R markdown file that contains text and images
includeMarkdown("StaticPosts/Geomorph.Rmd")),
tabPanel("Lake Levels",
includeMarkdown("StaticPosts/LakeLevels.Rmd")),
tabPanel("Land Use",
includeMarkdown("StaticPosts/LandUse.Rmd")),
tabPanel("Fisheries",
h5(p("Coming Soon"))),
tabPanel("Effects of Pollution",
includeMarkdown("StaticPosts/Pollution.Rmd"))
), # End of Topics tab
# About LOOOP tab----
tabPanel("About LOOOP", icon = icon("question-circle"),
fluidRow(column(6,
includeMarkdown("StaticPosts/About.Rmd"),
socialButton(href = "https://www.instagram.com/lake_looop/", icon = icon("instagram", "fa-5x"))),
column(6,align = "center",
img(src = "logo_looop.png", width = "400px",height = "400px"))
)
), # End of About tab
# Credits and Privacy Policy tab----
tabPanel("Credits and Privacy Policy", icon = icon("info-circle"),
includeMarkdown("StaticPosts/Credits-Policies.Rmd")
) #End of Policy tab
) # End of NavBarpage
) # End of Fluid Page
# Create server function (response to UI)----
server <- function(input, output, session){
# Create Dialog Box to keep user from reloading page
showModal(modalDialog(title= "Welcome to the LOOOP!",
"Use the Plot Options to begin exploring the data collected by the Upstate Freshwater Institute and use the tabs on the Navigation Bar to learn more about the Lake Ontario Watershed.
Click outside of this box to get started!",
size = "l",
easyClose = TRUE,
footer = NULL))
# Set up app with data and defining objects----
#load("~/GitHub/LOOOP/looop.rdata")
load("//aquadog/analysis/2021_LOOOP_NYSG_Small_Grant/06_Webpage-Shiny App/LOOOP/looop.rdata")
# Defining reactive objects
reactive_objects = reactiveValues()
# Map Set Up----
mymap <- createLeafletMap(session, "mymap")
# Draw Map with markers at data sites, set View of map to area of interest upon loading
session$onFlushed(once= T, function(){
output$mymap <- renderLeaflet({
leaflet() %>%
addProviderTiles(providers$Stamen.Terrain,
options = providerTileOptions(noWrap = TRUE)
) %>% setView(
lng = -76.354,
lat= 43.248,
zoom = 9
) %>% addCircleMarkers(
lng = mapframe$long,
lat = mapframe$lat,
popup = paste0(
"Station: ",mapframe$Station, "<br>",
"Depth(s): ",mapframe$U.Depths, "<br>",
"Year(s): ",mapframe$U.Years),
labelOptions = labelOptions(textsize = "15px")
)
})
})
# REACTIVITY----
# Filtering depth choices based on selected site----
site_choices <- reactive({
filter(b5, Station == input$site_choices)
})
observeEvent(site_choices(),{
choices <- unique(na.omit(site_choices()$Depth))
updateSelectInput(inputId = "depth", choices = choices)
})
depth <- reactive({
req(input$depth)
filter(site_choices(), Depth == input$depth)
})
# When station is selected, date slider that controls the X axis appears----
output$date_slider <- renderUI({
req(input$site_choices)
date_min = min(site_choices()$Date)
date_max = max(site_choices()$Date)
sliderInput("date_slider","Date range:", min = date_min, max = date_max, value = c(date_min,date_max),timeFormat = "%m-%d-%Y")
})
# Create new data frame that reacts to user selections and will update the plot code----
selectedData <- reactive({
b5 %>% filter(Station == input$site_choices,params==input$param_choices,Depth == input$depth, Datetime >= input$date_slider[1], Datetime <= input$date_slider[2]) %>%
complete(Date = seq.Date(min(Date, na.rm = T), max(Date, na.rm = T), by = 'day')) %>%
fill(c(Station, Depth, params,lat, long, U.Depths, U.Years, Ylabel))%>%
mutate(Abs.Time = replace_na(Abs.Time, "00:00:00"),
Datetime = as.POSIXct(paste(Date, Abs.Time), format = "%Y-%m-%d %H:%M" )
)
})
# Create a timeseries plot based on the selected options----
output$plot = renderPlot(
{req(input$date_slider)
# Plotting Information
ggplot(data = selectedData(), mapping = aes(x = Datetime, y = value))+
geom_point(size = 2)+
geom_line()+
theme_minimal()+
scale_y_continuous(name =  selectedData()$Ylabel,
limits = c(floor(min(selectedData()$value, na.rm = T)),ceiling(max(selectedData()$value,na.rm = T))),
breaks = pretty_breaks())+
scale_x_datetime(name = "Date")+
theme(
panel.border = element_rect(color = "black", fill = NA, size = 1),
axis.ticks = element_line(color = "black", size = 1),
axis.text = element_text(size = 15)
)
})
}
shiny::runApp('//aquadog/analysis/2021_LOOOP_NYSG_Small_Grant/06_Webpage-Shiny App/LOOOP')
install.packages("rsconnect")
rsconnect::setAccountInfo(name='looop', token='CF6008C9B6681F13EE2CF52009612E9C', secret='srgi+IGT64fvF1K8NL490+QkoL8MI7XSGnte//6X')
rsconnect::deployApp(dirname(rstudioapi::getActiveDocumentContext()$path))
# Set working directory and load packages----
my_packages <- c("lubridate", "plyr", "dplyr","tidyr", "stringi")
lapply(my_packages, require, character.only = TRUE)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
# Read in csv files of each dataset----
# 3 Rivers data, read all files into 1 dataset----
filenames <- list.files(path = './CSV_files/3Rivers', pattern = '*', full.names = TRUE)
b <- ldply(filenames, read.csv)
# Manipulated data so that it meets requirements for visualizations----
# 3 Rivers----
b$system.code <- as.character(b$system.code)
b$date <- as.Date(b$date,format = "%m/%d/%Y")
b$datetime <- as.POSIXct(paste(b$date, b$time), format = "%Y-%m-%d %H:%M") # Time cannot exist without date
# Adding time period factor based on collection time (1. 21:00-3:00, 2.  3:01-9:00, 3. 9:01-15:00, 4. 15:01-21:00)
b$timeperiod <- cut(hour(b$datetime), breaks = c(0, 3, 6, 9, 12, 15, 18, 21, 24), include.lowest = TRUE)
b <- b %>%
mutate(tp = lapply(timeperiod,
function(y)
if(y == "[0,3]"  | y == "(21,24]" )
1
else
if(y == "(3,6]"  | y == "(6,9]")
2
else
if(y == "(9,12]"  | y == "(12,15]" )
3
else 4))
b$tp <- as.factor(as.character(b$tp))
# Factor stations and add coordinates
b$station.code <- as.factor(as.character(b$station.code))
buoy.coord <-as.data.frame(unique(b$station.code))
names(buoy.coord) <-c("Station")
buoy.coord$lat <-c(43.240093,43.44995,43.205123,43.231178,43.193388,43.139376,43.147516,43.103883,43.100510,43.108055)
buoy.coord$long <- c(-76.147568,-76.50349,-76.269799,-76.309791,-76.279911,-76.238025,-76.314771,-76.445725,-76.499537,-76.475456)
#unique(b[c("system.code","station.code")],) # Check that the buoys are in the right river
# Round depth to nearest meter (determine if there's profiles, discrete depths, or typos)
b <- b %>%
mutate(r.depth = lapply(depth..m.,
function(x)
round(x, digits = 0)))
# unique(b[c("station.code","r.depth")]) # Typos= B211.6554, B224.-9999; Discrete = B148 @ 2; Profiles or multiple depths = B211, B143, B22, B224, B266, B317, B409, B430, CROSS
b$r.depth <-as.numeric(as.character(b$r.depth))
# Fixing typo
b$r.depth[b$station.code=="B211"& b$r.depth=="6554"]<- 3 # changing rounded depth to similar depth of other dates
# Cleaning data frame
b <- b %>% select(!c(time_id,data_id, ORP..mV.,timeperiod)) # Remove unnecessary columns
names(b) <- c("System", "Station", "Date", "Abs.Time", "Abs.Depth","Temp","SC","pH","DO","Tn","Chl","Datetime","Time","Depth") # Rename remaining columns
#cbind(lapply(lapply(b, is.na), sum)) # Identifying columns that have NAs
b1 <- b[!(is.na(b$Temp)) | !(is.na(b$SC)) | !(is.na(b$pH)) | !(is.na(b$DO))| !(is.na(b$Tn))| !(is.na(b$Chl)),] # Removing rows that have no data at all (Some NAs left within single columns for faulty probes, etc.)
b2 <- b1 %>% mutate(
year = year(Date)
)
b3 <- b2 %>% right_join(buoy.coord)
u.b <- data.frame(unique(b3[c("Station","Depth","year")]))
u.b <- u.b[order(u.b$Depth),]
u.b <- u.b %>% group_by(Station) %>%
summarise_all(funs(trimws(paste(., collapse = ", "))))
u.b2 <- as.data.frame(unique(u.b$Station))
u.b2$U.Depths <- c("2-5 meters","2 meters","2-3 meters","1-3 meters","1-4 meters","1-6 meters","1-7 meters","1-6 meters","1-4 meters","1-16 meters")
u.b2$U.Years <- c("2008, 2009",
"2008, 2009",
"2008, 2009",
"2008, 2009",
"2002, 2003, 2008, 2009",
"2000 , 2006",
"2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009",
"2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009",
"2004, 2005, 2006, 2007, 2008, 2009",
"2006, 2009")
names(u.b2) <- c("Station","U.Depths","U.Years")
b3 <- b3 %>% right_join(u.b2) %>% select(!c(System))
# Separate dataframe by Station and fill in time gaps with NAs
station_split <- split(b3,b3$Station)
station_names <- as.character(unique(b3$Station))
for(i in 1:length(station_split)){
assign(station_names[i],station_split[[i]])
}
B143 <- B143 %>% arrange(Date) %>% complete(Date = seq.Date(min(Date, na.rm = T), max(Date, na.rm = T), by = 'day')) %>% fill(c(Station, lat, long, U.Depths, U.Years)) %>% mutate(year = year(Date))
B148 <- B148 %>% arrange(Date) %>% complete(Date = seq.Date(min(Date, na.rm = T), max(Date, na.rm = T), by = 'day'))%>% fill(c(Station, lat, long, U.Depths, U.Years)) %>% mutate(year = year(Date))
B211 <- B211 %>% arrange(Date) %>%complete(Date = seq.Date(min(Date, na.rm = T), max(Date, na.rm = T), by = 'day'))%>% fill(c(Station, lat, long, U.Depths, U.Years)) %>% mutate(year = year(Date))
B22 <- B22 %>% arrange(Date) %>%complete(Date = seq.Date(min(Date, na.rm = T), max(Date, na.rm = T), by = 'day'))%>% fill(c(Station, lat, long, U.Depths, U.Years)) %>% mutate(year = year(Date))
B224 <- B224 %>% arrange(Date) %>%complete(Date = seq.Date(min(Date, na.rm = T), max(Date, na.rm = T), by = 'day'))%>% fill(c(Station, lat, long, U.Depths, U.Years)) %>% mutate(year = year(Date))
B266 <- B266 %>% arrange(Date) %>%complete(Date = seq.Date(min(Date, na.rm = T), max(Date, na.rm = T), by = 'day'))%>% fill(c(Station, lat, long, U.Depths, U.Years)) %>% mutate(year = year(Date))
B317 <- B317 %>% arrange(Date) %>%complete(Date = seq.Date(min(Date, na.rm = T), max(Date, na.rm = T), by = 'day'))%>% fill(c(Station, lat, long, U.Depths, U.Years)) %>% mutate(year = year(Date))
B409 <- B409 %>% arrange(Date) %>%complete(Date = seq.Date(min(Date, na.rm = T), max(Date, na.rm = T), by = 'day'))%>% fill(c(Station, lat, long, U.Depths, U.Years)) %>% mutate(year = year(Date))
B430 <- B430 %>% arrange(Date) %>%complete(Date = seq.Date(min(Date, na.rm = T), max(Date, na.rm = T), by = 'day'))%>% fill(c(Station, lat, long, U.Depths, U.Years)) %>% mutate(year = year(Date))
CROSS <- CROSS %>% arrange(Date) %>%complete(Date = seq.Date(min(Date, na.rm = T), max(Date, na.rm = T), by = 'day'))%>% fill(c(Station, lat, long, U.Depths, U.Years)) %>% mutate(year = year(Date))
# Recombine Station dataframes for complete dataframe that can be used to show holes in plots
b4 <- rbind(B143,B148,B211,B22,B224,B266,B317,B409,B430,CROSS)
b4 <- b4 %>% mutate(Abs.Time = replace_na(Abs.Time, "00:00:00")) %>% mutate(Datetime = as.POSIXct(paste(Date, Abs.Time), format = "%Y-%m-%d %H:%M"))
b5 <- b4 %>% pivot_longer(.,c(Temp,SC,pH,DO,Tn,Chl), names_to = "params",values_to = "value")
b5$Depth <- as.factor(as.character(b5$Depth))
b5$params <- as.factor(as.character(b5$params))
b5 <- b5 %>% mutate(Ylabel = case_when(
stri_detect_regex(params, "Temp") ~ "Temperature (deg.C)",
stri_detect_regex(params, "SC") ~ "Specific Conductance (uS/cm)",
stri_detect_regex(params, "pH") ~ "pH (units)",
stri_detect_regex(params, "DO") ~ "Dissolved Oxygen (mg/l)",
stri_detect_regex(params, "Tn") ~ "Turbidity (NTU)",
stri_detect_regex(params, "Chl") ~ "Chlorophyll-a (ug/l)"
))
river.data <- b5 %>% arrange(Date)
str(river.data)
library(shiny)
library(shinydashboard)
library(shinydashboardPlus)
#library(rsconnect)
library(leaflet)
library(rstudioapi)
library(shinycssloaders)
library(rmarkdown)
library(lubridate)
library(plyr)
library(dplyr)
library(tidyr)
library(ggplot2)
library(knitr)
library(scales)
# Choices for drop downs----
param_choices <- c("Temperature (deg. C)"="Temp", "Specific Conductance (uS/cm)"="SC", "pH (units)"="pH", "Dissolved Oxygen (mg/L)"="DO", "Turbidity (NTU)"="Tn", "Chlorophyll-a (ug/L)"="Chl")
sites <- c("B143", "B148", "B211", "B22", "B224", "B266", "B317", "B409", "B430", "CROSS")
depth_choices <-list("1" = 1, "2" = 2, "3" = 3, "4" = 4, "5" = 5, "6" = 6, "7" = 7)
# Create User Interface (UI)----
ui <- dashboardPage(
dashboardHeader(title = "LOOOP"),
dashboardSidebar(),
dashboardBody(
fluidRow(
box(plotOutput("plot1", height = 250)),
box(title = "Controls",
selectInput("param_choices","Parameter:", param_choices),
selectInput("site_choices", "Station:", sites),
selectInput("depth","Depth:", NULL)
,
uiOutput("date_slider")
)
) # Row
) # Dash Body
)# Dash Page
# Create server function (response to UI)----
server <- function(input, output, session){
load("riverdata.rdata")
site_choices <-reactive({
return(subset(river.data, Station == input$site_choices))
})
observeEvent(site_choices(),{
d.choices <- unique(na.omit(site_choices()$Depth))
updateSelectInput(inputId = "depth", choices = d.choices)
})
depth <- reactive({
req(input$depth)
filter(site_choices(), Depth == input$depth)
})
output$date_slider <- renderUI({
req(input$site_choices)
date_min= min(site_choices()$Datetime)
date_max = max(site_choices()$Datetime)
sliderInput("date_slider","Date Range:", min = date_min, max = date_max, value = c(date_min,date_max),timeFormat = "%m-%d-%Y HH:MM")
})
our.data <- reactive({
return(subset(river.data, (params %in% input$param_choices & Station %in% input$site_choices & Depth %in% input$depth | is.na(Abs.Depth))))
return(subset(river.data, (Datetime >= input$date_slider[1] & Datetime <= input$date_slider[2])))
})
output$plot1 <- renderPlot({
ggplot(data = our.data(), mapping = aes(x = Datetime, y = value))+
geom_point(size = 2)+
geom_line()+
theme_minimal()+
labs(x = "Date and Time", y = names(param_choices[which(param_choices == input$param_choices)]))+
scale_x_datetime(limits = c(input$date_slider[1],input$date_slider[2]),
breaks = pretty_breaks())+
theme(
panel.border = element_rect(color = "black", fill = NA, size = 1),
axis.ticks = element_line(color = "black", size = 1),
axis.text = element_text(size = 15)
)
})
}
## Run app----
shinyApp(ui = ui, server = server)
# Create User Interface (UI)----
ui <- dashboardPage(
dashboardHeader(title = "LOOOP"),
dashboardSidebar(),
dashboardBody(
fluidRow(
box(plotOutput("plot1", height = 250)),
box(title = "Controls",
selectInput("param_choices","Parameter:", param_choices),
selectInput("site_choices", "Station:", sites),
selectInput("depth","Depth:", NULL)
,
uiOutput("date_slider")
)
) # Row
) # Dash Body
)# Dash Page
# Create server function (response to UI)----
server <- function(input, output, session){
load("riverdata.rdata")
site_choices <-reactive({
return(subset(river.data, Station == input$site_choices))
})
observeEvent(site_choices(),{
d.choices <- unique(na.omit(site_choices()$Depth))
updateSelectInput(inputId = "depth", choices = d.choices)
})
depth <- reactive({
req(input$depth)
filter(site_choices(), Depth == input$depth)
})
output$date_slider <- renderUI({
req(input$site_choices)
date_min= min(site_choices()$Datetime)
date_max = max(site_choices()$Datetime)
sliderInput("date_slider","Date Range:", min = date_min, max = date_max, value = c(date_min,date_max),timezone = "EST")
})
our.data <- reactive({
return(subset(river.data, (params %in% input$param_choices & Station %in% input$site_choices & Depth %in% input$depth | is.na(Abs.Depth))))
return(subset(river.data, (Datetime >= input$date_slider[1] & Datetime <= input$date_slider[2])))
})
output$plot1 <- renderPlot({
ggplot(data = our.data(), mapping = aes(x = Datetime, y = value))+
geom_point(size = 2)+
geom_line()+
theme_minimal()+
labs(x = "Date and Time", y = names(param_choices[which(param_choices == input$param_choices)]))+
scale_x_datetime(limits = c(input$date_slider[1],input$date_slider[2]),
breaks = pretty_breaks())+
theme(
panel.border = element_rect(color = "black", fill = NA, size = 1),
axis.ticks = element_line(color = "black", size = 1),
axis.text = element_text(size = 15)
)
})
}
## Run app----
shinyApp(ui = ui, server = server)
# Create server function (response to UI)----
server <- function(input, output, session){
load("riverdata.rdata")
site_choices <-reactive({
return(subset(river.data, Station == input$site_choices))
})
observeEvent(site_choices(),{
d.choices <- unique(na.omit(site_choices()$Depth))
updateSelectInput(inputId = "depth", choices = d.choices)
})
depth <- reactive({
req(input$depth)
filter(site_choices(), Depth == input$depth)
})
output$date_slider <- renderUI({
req(input$site_choices)
date_min= min(site_choices()$Datetime)
date_max = max(site_choices()$Datetime)
sliderInput("date_slider","Date Range:", min = date_min, max = date_max, value = c(date_min,date_max),timezone = "EST")
})
our.data <- reactive({
return(subset(river.data, (params %in% input$param_choices & Station %in% input$site_choices & Depth %in% input$depth | is.na(Abs.Depth))))
return(subset(river.data, (Datetime >= input$date_slider[1] & Datetime <= input$date_slider[2])))
})
output$plot1 <- renderPlot({
ggplot(data = our.data(), mapping = aes(x = Datetime, y = value))+
geom_point(size = 2)+
geom_line()+
theme_minimal()+
labs(x = "Date and Time", y = names(param_choices[which(param_choices == input$param_choices)]))+
scale_x_datetime(limits = c(input$date_slider[1],input$date_slider[2]),
breaks = pretty_breaks(),
minor_breaks = pretty_dates())+
theme(
panel.border = element_rect(color = "black", fill = NA, size = 1),
axis.ticks = element_line(color = "black", size = 1),
axis.text = element_text(size = 15)
)
})
}
## Run app----
shinyApp(ui = ui, server = server)
# Create server function (response to UI)----
server <- function(input, output, session){
load("riverdata.rdata")
site_choices <-reactive({
return(subset(river.data, Station == input$site_choices))
})
observeEvent(site_choices(),{
d.choices <- unique(na.omit(site_choices()$Depth))
updateSelectInput(inputId = "depth", choices = d.choices)
})
depth <- reactive({
req(input$depth)
filter(site_choices(), Depth == input$depth)
})
output$date_slider <- renderUI({
req(input$site_choices)
date_min= min(site_choices()$Datetime)
date_max = max(site_choices()$Datetime)
sliderInput("date_slider","Date Range:", min = date_min, max = date_max, value = c(date_min,date_max),timezone = "EST")
})
our.data <- reactive({
return(subset(river.data, (params %in% input$param_choices & Station %in% input$site_choices & Depth %in% input$depth | is.na(Abs.Depth))))
return(subset(river.data, (Datetime >= input$date_slider[1] & Datetime <= input$date_slider[2])))
})
output$plot1 <- renderPlot({
ggplot(data = our.data(), mapping = aes(x = Datetime, y = value))+
geom_point(size = 2)+
geom_line()+
theme_minimal()+
labs(x = "Date and Time", y = names(param_choices[which(param_choices == input$param_choices)]))+
scale_x_datetime(limits = c(input$date_slider[1],input$date_slider[2]),
breaks = breaks_pretty())+
theme(
panel.border = element_rect(color = "black", fill = NA, size = 1),
axis.ticks = element_line(color = "black", size = 1),
axis.text = element_text(size = 15)
)
})
}
## Run app----
shinyApp(ui = ui, server = server)
# Create server function (response to UI)----
server <- function(input, output, session){
load("riverdata.rdata")
site_choices <-reactive({
return(subset(river.data, Station == input$site_choices))
})
observeEvent(site_choices(),{
d.choices <- unique(na.omit(site_choices()$Depth))
updateSelectInput(inputId = "depth", choices = d.choices)
})
depth <- reactive({
req(input$depth)
filter(site_choices(), Depth == input$depth)
})
output$date_slider <- renderUI({
req(input$site_choices)
date_min= min(site_choices()$Datetime)
date_max = max(site_choices()$Datetime)
sliderInput("date_slider","Date Range:", min = date_min, max = date_max, value = c(date_min,date_max),timezone = "EST")
})
our.data <- reactive({
return(subset(river.data, (params %in% input$param_choices & Station %in% input$site_choices & Depth %in% input$depth | is.na(Abs.Depth))))
return(subset(river.data, (Datetime >= input$date_slider[1] & Datetime <= input$date_slider[2])))
})
output$plot1 <- renderPlot({
ggplot(data = our.data(), mapping = aes(x = Datetime, y = value))+
geom_point(size = 2)+
geom_line()+
theme_minimal()+
labs(x = "Date and Time", y = names(param_choices[which(param_choices == input$param_choices)]))+
scale_x_datetime(limits = c(input$date_slider[1],input$date_slider[2]),
breaks = breaks_pretty(),
labels = label_date_short(format = c("%Y", "%b", "%d", "%H:%M"), sep = "\n"))+
theme(
panel.border = element_rect(color = "black", fill = NA, size = 1),
axis.ticks = element_line(color = "black", size = 1),
axis.text = element_text(size = 15)
)
})
}
## Run app----
shinyApp(ui = ui, server = server)
?icon
