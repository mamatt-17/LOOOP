req(input$depth)
filter(site_choices(), Depth == input$depth)
})
our.data <- reactive({
return(subset(river.data, (params %in% input$param_choices & Station %in% input$site_choices & Depth %in% input$depth)))
})
output$date_slider <- renderUI({
req(input$site_choices)
date_min = min(site_choices()$Date)
date_max = max(site_choices()$Date)
sliderInput("date_slider","Date range:", min = date_min, max = date_max, value = c(date_min, date_max), timeFormat = "%m-%d-%Y")
})
output$plot1 <- renderPlot({
ggplot(data = our.data(), mapping = aes(x = Datetime, y = value))+
geom_point(size = 2)+
geom_line()+
theme_minimal()+
scale_y_continuous(name =  our.data$Ylabel,
limits = c(floor(min(our.data()$value, na.rm = T)),ceiling(max(our.data()$value,na.rm = T))),
breaks = pretty_breaks())+
scale_x_datetime(name = "Date")+
theme(
panel.border = element_rect(color = "black", fill = NA, size = 1),
axis.ticks = element_line(color = "black", size = 1),
axis.text = element_text(size = 15)
)
})
}
## Run app----
shinyApp(ui = ui, server = server)
library(scales)
# Create server function (response to UI)----
server <- function(input, output, session){
load("riverdata.rdata")
site_choices <-reactive({
return(subset(river.data, Station == input$site_choices))
})
observeEvent(site_choices(),{
d.choices <- unique(na.omit(site_choices()$Depth))
updateSelectInput(inputId = "depth", choices = d.choices)
})
depth <- reactive({
req(input$depth)
filter(site_choices(), Depth == input$depth)
})
our.data <- reactive({
return(subset(river.data, (params %in% input$param_choices & Station %in% input$site_choices & Depth %in% input$depth)))
})
output$date_slider <- renderUI({
req(input$site_choices)
date_min = min(site_choices()$Date)
date_max = max(site_choices()$Date)
sliderInput("date_slider","Date range:", min = date_min, max = date_max, value = c(date_min, date_max), timeFormat = "%m-%d-%Y")
})
output$plot1 <- renderPlot({
ggplot(data = our.data(), mapping = aes(x = Datetime, y = value))+
geom_point(size = 2)+
geom_line()+
theme_minimal()+
scale_y_continuous(name =  our.data$Ylabel,
limits = c(floor(min(our.data()$value, na.rm = T)),ceiling(max(our.data()$value,na.rm = T))),
breaks = pretty_breaks())+
scale_x_datetime(name = "Date")+
theme(
panel.border = element_rect(color = "black", fill = NA, size = 1),
axis.ticks = element_line(color = "black", size = 1),
axis.text = element_text(size = 15)
)
})
}
## Run app----
shinyApp(ui = ui, server = server)
# Create server function (response to UI)----
server <- function(input, output, session){
load("riverdata.rdata")
site_choices <-reactive({
return(subset(river.data, Station == input$site_choices))
})
observeEvent(site_choices(),{
d.choices <- unique(na.omit(site_choices()$Depth))
updateSelectInput(inputId = "depth", choices = d.choices)
})
depth <- reactive({
req(input$depth)
filter(site_choices(), Depth == input$depth)
})
our.data <- reactive({
return(subset(river.data, (params %in% input$param_choices & Station %in% input$site_choices & Depth %in% input$depth)))
})
output$date_slider <- renderUI({
req(input$site_choices)
date_min = min(site_choices()$Date)
date_max = max(site_choices()$Date)
sliderInput("date_slider","Date range:", min = date_min, max = date_max, value = c(date_min, date_max), timeFormat = "%m-%d-%Y")
})
output$plot1 <- renderPlot({
ggplot(data = our.data(), mapping = aes(x = Datetime, y = value))+
geom_point(size = 2)+
geom_line()+
theme_minimal()+
scale_y_continuous(name =  our.data$Ylabel,
#limits = c(floor(min(our.data()$value, na.rm = T)),ceiling(max(our.data()$value,na.rm = T))),
breaks = pretty_breaks())+
scale_x_datetime(name = "Date")+
theme(
panel.border = element_rect(color = "black", fill = NA, size = 1),
axis.ticks = element_line(color = "black", size = 1),
axis.text = element_text(size = 15)
)
})
}
## Run app----
shinyApp(ui = ui, server = server)
# Set working directory and load packages----
my_packages <- c("lubridate", "plyr", "dplyr","tidyr", "stringi")
lapply(my_packages, require, character.only = TRUE)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
# Read in csv files of each dataset----
# 3 Rivers data, read all files into 1 dataset----
filenames <- list.files(path = './CSV_files/3Rivers', pattern = '*', full.names = TRUE)
b <- ldply(filenames, read.csv)
# Manipulated data so that it meets requirements for visualizations----
# 3 Rivers----
b$system.code <- as.character(b$system.code)
b$date <- as.Date(b$date,format = "%m/%d/%Y")
b$datetime <- as.POSIXct(paste(b$date, b$time), format = "%Y-%m-%d %H:%M") # Time cannot exist without date
# Adding time period factor based on collection time (1. 21:00-3:00, 2.  3:01-9:00, 3. 9:01-15:00, 4. 15:01-21:00)
b$timeperiod <- cut(hour(b$datetime), breaks = c(0, 3, 6, 9, 12, 15, 18, 21, 24), include.lowest = TRUE)
b <- b %>%
mutate(tp = lapply(timeperiod,
function(y)
if(y == "[0,3]"  | y == "(21,24]" )
1
else
if(y == "(3,6]"  | y == "(6,9]")
2
else
if(y == "(9,12]"  | y == "(12,15]" )
3
else 4))
b$tp <- as.factor(as.character(b$tp))
# Factor stations and add coordinates
b$station.code <- as.factor(as.character(b$station.code))
buoy.coord <-as.data.frame(unique(b$station.code))
names(buoy.coord) <-c("Station")
buoy.coord$lat <-c(43.240093,43.44995,43.205123,43.231178,43.193388,43.139376,43.147516,43.103883,43.100510,43.108055)
buoy.coord$long <- c(-76.147568,-76.50349,-76.269799,-76.309791,-76.279911,-76.238025,-76.314771,-76.445725,-76.499537,-76.475456)
#unique(b[c("system.code","station.code")],) # Check that the buoys are in the right river
# Round depth to nearest meter (determine if there's profiles, discrete depths, or typos)
b <- b %>%
mutate(r.depth = lapply(depth..m.,
function(x)
round(x, digits = 0)))
# unique(b[c("station.code","r.depth")]) # Typos= B211.6554, B224.-9999; Discrete = B148 @ 2; Profiles or multiple depths = B211, B143, B22, B224, B266, B317, B409, B430, CROSS
b$r.depth <-as.numeric(as.character(b$r.depth))
# Fixing typo
b$r.depth[b$station.code=="B211"& b$r.depth=="6554"]<- 3 # changing rounded depth to similar depth of other dates
# Cleaning data frame
b <- b %>% select(!c(time_id,data_id, ORP..mV.,timeperiod)) # Remove unnecessary columns
names(b) <- c("System", "Station", "Date", "Abs.Time", "Abs.Depth","Temp","SC","pH","DO","Tn","Chl","Datetime","Time","Depth") # Rename remaining columns
#cbind(lapply(lapply(b, is.na), sum)) # Identifying columns that have NAs
b1 <- b[!(is.na(b$Temp)) | !(is.na(b$SC)) | !(is.na(b$pH)) | !(is.na(b$DO))| !(is.na(b$Tn))| !(is.na(b$Chl)),] # Removing rows that have no data at all (Some NAs left within single columns for faulty probes, etc.)
b2 <- b1 %>% mutate(
year = year(Date)
)
b3 <- b2 %>% right_join(buoy.coord)
u.b <- data.frame(unique(b3[c("Station","Depth","year")]))
u.b <- u.b[order(u.b$Depth),]
u.b <- u.b %>% group_by(Station) %>%
summarise_all(funs(trimws(paste(., collapse = ", "))))
u.b2 <- as.data.frame(unique(u.b$Station))
u.b2$U.Depths <- c("2-5 meters","2 meters","2-3 meters","1-3 meters","1-4 meters","1-6 meters","1-7 meters","1-6 meters","1-4 meters","1-16 meters")
u.b2$U.Years <- c("2008, 2009",
"2008, 2009",
"2008, 2009",
"2008, 2009",
"2002, 2003, 2008, 2009",
"2000 , 2006",
"2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009",
"2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009",
"2004, 2005, 2006, 2007, 2008, 2009",
"2006, 2009")
names(u.b2) <- c("Station","U.Depths","U.Years")
b3 <- b3 %>% right_join(u.b2) %>% select(!c(System))
# Separate dataframe by Station and fill in time gaps with NAs
station_split <- split(b3,b3$Station)
station_names <- as.character(unique(b3$Station))
for(i in 1:length(station_split)){
assign(station_names[i],station_split[[i]])
}
B143 <- B143 %>% complete(Date = seq.Date(min(Date, na.rm = T), max(Date, na.rm = T), by = 'day')) %>% fill(c(Station, lat, long, U.Depths, U.Years)) %>% mutate(year = year(Date))
B148 <- B148 %>% complete(Date = seq.Date(min(Date, na.rm = T), max(Date, na.rm = T), by = 'day'))%>% fill(c(Station, lat, long, U.Depths, U.Years)) %>% mutate(year = year(Date))
B211 <- B211 %>% complete(Date = seq.Date(min(Date, na.rm = T), max(Date, na.rm = T), by = 'day'))%>% fill(c(Station, lat, long, U.Depths, U.Years)) %>% mutate(year = year(Date))
B22 <- B22 %>% complete(Date = seq.Date(min(Date, na.rm = T), max(Date, na.rm = T), by = 'day'))%>% fill(c(Station, lat, long, U.Depths, U.Years)) %>% mutate(year = year(Date))
B224 <- B224 %>% complete(Date = seq.Date(min(Date, na.rm = T), max(Date, na.rm = T), by = 'day'))%>% fill(c(Station, lat, long, U.Depths, U.Years)) %>% mutate(year = year(Date))
B266 <- B266 %>% complete(Date = seq.Date(min(Date, na.rm = T), max(Date, na.rm = T), by = 'day'))%>% fill(c(Station, lat, long, U.Depths, U.Years)) %>% mutate(year = year(Date))
B317 <- B317 %>% complete(Date = seq.Date(min(Date, na.rm = T), max(Date, na.rm = T), by = 'day'))%>% fill(c(Station, lat, long, U.Depths, U.Years)) %>% mutate(year = year(Date))
B409 <- B409 %>% complete(Date = seq.Date(min(Date, na.rm = T), max(Date, na.rm = T), by = 'day'))%>% fill(c(Station, lat, long, U.Depths, U.Years)) %>% mutate(year = year(Date))
B430 <- B430 %>% complete(Date = seq.Date(min(Date, na.rm = T), max(Date, na.rm = T), by = 'day'))%>% fill(c(Station, lat, long, U.Depths, U.Years)) %>% mutate(year = year(Date))
CROSS <- CROSS %>% complete(Date = seq.Date(min(Date, na.rm = T), max(Date, na.rm = T), by = 'day'))%>% fill(c(Station, lat, long, U.Depths, U.Years)) %>% mutate(year = year(Date))
# Recombine Station dataframes for complete dataframe that can be used to show holes in plots
b4 <- rbind(B143,B148,B211,B22,B224,B266,B317,B409,B430,CROSS)
b4 <- b4 %>% mutate(Abs.Time = replace_na(Abs.Time, "00:00:00")) %>% mutate(Datetime = as.POSIXct(paste(Date, Abs.Time), format = "%Y-%m-%d %H:%M"))
b5 <- b4 %>% pivot_longer(.,c(Temp,SC,pH,DO,Tn,Chl), names_to = "params",values_to = "value")
b5$Depth <- as.factor(as.character(b5$Depth))
b5$params <- as.factor(as.character(b5$params))
b5 <- b5 %>% mutate(Ylabel = case_when(
stri_detect_regex(params, "Temp") ~ "Temperature (°C)",
stri_detect_regex(params, "SC") ~ "Specific Conductance (",mu,"S/cm)",
stri_detect_regex(params, "pH") ~ "pH (units)",
stri_detect_regex(params, "DO") ~ "Dissolved Oxygen (mg/l)",
stri_detect_regex(params, "Tn") ~ "Turbidity (NTU)",
stri_detect_regex(params, "Chl") ~ "Chlorophyll-a (",mu,"g/l)"
))
b5 <- b5 %>% group_by(Station)%>% arrange(Depth, .by_group = TRUE)
list.dataframe <- list(B143,B148,B211,B22,B224,B266,B317,B409,B430,CROSS)
river.data <- b5
View(river.data)
river.data[is.na(river.data$Date)]
river.data[is.na(river.data$Date),]
library(shiny)
library(shinydashboard)
library(shinydashboardPlus)
#library(rsconnect)
library(leaflet)
library(rstudioapi)
library(shinycssloaders)
library(rmarkdown)
library(lubridate)
library(plyr)
library(dplyr)
library(tidyr)
library(ggplot2)
library(knitr)
library(scales)
# Choices for drop downs----
param_choices <- c("Temperature"="Temp", "Specific Conductance"="SC", "pH"="pH", "Dissolved Oxygen"="DO", "Turbidity"="Tn", "Chlorophyll-a"="Chl")
sites <- c("B143", "B148", "B211", "B22", "B224", "B266", "B317", "B409", "B430", "CROSS")
depth_choices <-list("1" = 1, "2" = 2, "3" = 3, "4" = 4, "5" = 5, "6" = 6, "7" = 7)
# Create User Interface (UI)----
ui <- dashboardPage(
dashboardHeader(title = "LOOOP-Lake Ontario, Oneida, Onondaga Program"),
dashboardSidebar(),
dashboardBody(
fluidRow(
box(plotOutput("plot1", height = 250)),
box(title = "Controls",
selectInput("param_choices","Parameter:", param_choices),
selectInput("site_choices", "Station:", sites),
selectInput("depth","Depth:", NULL),
sliderInput("date_slider", "Dates:")
)
) # Row
) # Dash Body
)# Dash Page
# Create server function (response to UI)----
server <- function(input, output, session){
load("riverdata.rdata")
site_choices <-reactive({
return(subset(river.data, Station == input$site_choices))
})
observeEvent(site_choices(),{
d.choices <- unique(na.omit(site_choices()$Depth))
updateSelectInput(inputId = "depth", choices = d.choices)
})
depth <- reactive({
req(input$depth)
filter(site_choices(), Depth == input$depth)
})
our.data <- reactive({
return(subset(river.data, (params %in% input$param_choices & Station %in% input$site_choices & Depth %in% input$depth)))
})
#  output$date_slider <- renderUI({
#   req(input$site_choices)
#  date_min = min(site_choices()$Date)
# date_max = max(site_choices()$Date)
#sliderInput("date_slider","Date range:", min = date_min, max = date_max, value = c(date_min, date_max), timeFormat = "%m-%d-%Y")
#})
output$plot1 <- renderPlot({
our.data() %>% filter(Date >= input$date_slider[1] & Date <= input$date_slider[2]) %>%
ggplot(data = our.data(), mapping = aes(x = Datetime, y = value))+
geom_point(size = 2)+
geom_line()+
theme_minimal()+
scale_y_continuous(name =  our.data$Ylabel,
#limits = c(floor(min(our.data()$value, na.rm = T)),ceiling(max(our.data()$value,na.rm = T))),
breaks = pretty_breaks())+
scale_x_datetime(name = "Date")+
theme(
panel.border = element_rect(color = "black", fill = NA, size = 1),
axis.ticks = element_line(color = "black", size = 1),
axis.text = element_text(size = 15)
)
})
}
## Run app----
shinyApp(ui = ui, server = server)
# Create User Interface (UI)----
ui <- dashboardPage(
dashboardHeader(title = "LOOOP-Lake Ontario, Oneida, Onondaga Program"),
dashboardSidebar(),
dashboardBody(
fluidRow(
box(plotOutput("plot1", height = 250)),
box(title = "Controls",
selectInput("param_choices","Parameter:", param_choices),
selectInput("site_choices", "Station:", sites),
selectInput("depth","Depth:", NULL),
sliderInput("date_slider", "Dates:",
min = as.POSIXct("2000-01-01","%Y-%m-%d"),
max = as.POSIXct("2011-01-01","%Y-%m-%d"),
value = c(as.POSIXct("2000-05-01","%Y-%m-%d"), as.POSIXct("2010-10-01","%Y-%m-%d")),
timeFormat = "%Y-%m-%d", step = 1)
)
) # Row
) # Dash Body
)# Dash Page
warnings()
## Run app----
shinyApp(ui = ui, server = server)
# Create User Interface (UI)----
ui <- dashboardPage(
dashboardHeader(title = "LOOOP-Lake Ontario, Oneida, Onondaga Program"),
dashboardSidebar(),
dashboardBody(
fluidRow(
box(plotOutput("plot1", height = 250)),
box(title = "Controls",
selectInput("param_choices","Parameter:", param_choices),
selectInput("site_choices", "Station:", sites),
selectInput("depth","Depth:", NULL),
sliderInput("date_slider", "Dates:",
min = as.POSIXct("2000-07-01","%Y-%m-%d"),
max = as.POSIXct("2010-01-01","%Y-%m-%d"),
value = c(as.POSIXct("2000-08-01","%Y-%m-%d"), as.POSIXct("2010-08-01","%Y-%m-%d")),
timeFormat = "%Y-%m-%d", step = 1)
)
) # Row
) # Dash Body
)# Dash Page
# Create server function (response to UI)----
server <- function(input, output, session){
load("riverdata.rdata")
site_choices <-reactive({
return(subset(river.data, Station == input$site_choices))
})
observeEvent(site_choices(),{
d.choices <- unique(na.omit(site_choices()$Depth))
updateSelectInput(inputId = "depth", choices = d.choices)
})
depth <- reactive({
req(input$depth)
filter(site_choices(), Depth == input$depth)
})
our.data <- reactive({
return(subset(river.data, (params %in% input$param_choices & Station %in% input$site_choices & Depth %in% input$depth)))
})
#  output$date_slider <- renderUI({
#   req(input$site_choices)
#  date_min = min(site_choices()$Date)
# date_max = max(site_choices()$Date)
#sliderInput("date_slider","Date range:", min = date_min, max = date_max, value = c(date_min, date_max), timeFormat = "%m-%d-%Y")
#})
output$plot1 <- renderPlot({
our.data() %>% filter(Date >= input$date_slider[1] & Date <= input$date_slider[2]) %>%
ggplot(data = our.data(), mapping = aes(x = Datetime, y = value))+
geom_point(size = 2)+
geom_line()+
theme_minimal()+
scale_y_continuous(name =  our.data$Ylabel,
#limits = c(floor(min(our.data()$value, na.rm = T)),ceiling(max(our.data()$value,na.rm = T))),
breaks = pretty_breaks())+
scale_x_datetime(name = "Date")+
theme(
panel.border = element_rect(color = "black", fill = NA, size = 1),
axis.ticks = element_line(color = "black", size = 1),
axis.text = element_text(size = 15)
)
})
}
## Run app----
shinyApp(ui = ui, server = server)
# Create server function (response to UI)----
server <- function(input, output, session){
load("riverdata.rdata")
site_choices <-reactive({
return(subset(river.data, Station == input$site_choices))
})
observeEvent(site_choices(),{
d.choices <- unique(na.omit(site_choices()$Depth))
updateSelectInput(inputId = "depth", choices = d.choices)
})
depth <- reactive({
req(input$depth)
filter(site_choices(), Depth == input$depth)
})
our.data <- reactive({
return(subset(river.data, (params %in% input$param_choices & Station %in% input$site_choices & Depth %in% input$depth)))
})
observeEvent({
our.data() %>% filter(Date >= input$date_slider[1] & Date <= input$date_slider[2])
})
output$plot1 <- renderPlot({
ggplot(data = our.data(), mapping = aes(x = Datetime, y = value))+
geom_point(size = 2)+
geom_line()+
theme_minimal()+
scale_y_continuous(name =  our.data$Ylabel,
#limits = c(floor(min(our.data()$value, na.rm = T)),ceiling(max(our.data()$value,na.rm = T))),
breaks = pretty_breaks())+
scale_x_datetime(name = "Date")+
theme(
panel.border = element_rect(color = "black", fill = NA, size = 1),
axis.ticks = element_line(color = "black", size = 1),
axis.text = element_text(size = 15)
)
})
}
## Run app----
shinyApp(ui = ui, server = server)
# Create server function (response to UI)----
server <- function(input, output, session){
load("riverdata.rdata")
site_choices <-reactive({
return(subset(river.data, Station == input$site_choices))
})
observeEvent(site_choices(),{
d.choices <- unique(na.omit(site_choices()$Depth))
updateSelectInput(inputId = "depth", choices = d.choices)
})
depth <- reactive({
req(input$depth)
filter(site_choices(), Depth == input$depth)
})
our.data <- reactive({
return(subset(river.data, (params %in% input$param_choices & Station %in% input$site_choices & Depth %in% input$depth)))
our.data() %>% filter(Date >= input$date_slider[1] & Date <= input$date_slider[2])
})
output$plot1 <- renderPlot({
ggplot(data = our.data(), mapping = aes(x = Datetime, y = value))+
geom_point(size = 2)+
geom_line()+
theme_minimal()+
scale_y_continuous(name =  our.data$Ylabel,
#limits = c(floor(min(our.data()$value, na.rm = T)),ceiling(max(our.data()$value,na.rm = T))),
breaks = pretty_breaks())+
scale_x_datetime(name = "Date")+
theme(
panel.border = element_rect(color = "black", fill = NA, size = 1),
axis.ticks = element_line(color = "black", size = 1),
axis.text = element_text(size = 15)
)
})
}
## Run app----
shinyApp(ui = ui, server = server)
# Create User Interface (UI)----
ui <- dashboardPage(
dashboardHeader(title = "LOOOP"),
dashboardSidebar(),
dashboardBody(
fluidRow(
box(plotOutput("plot1", height = 250)),
box(title = "Controls",
selectInput("param_choices","Parameter:", param_choices),
selectInput("site_choices", "Station:", sites),
selectInput("depth","Depth:", NULL),
#  sliderInput("date_slider", "Dates:",
#             min = as.POSIXct("2000-07-01","%Y-%m-%d"),
#            max = as.POSIXct("2010-01-01","%Y-%m-%d"),
#           value = c(as.POSIXct("2000-08-01","%Y-%m-%d"), as.POSIXct("2010-08-01","%Y-%m-%d")),
#          timeFormat = "%Y-%m-%d", step = 1)
)
) # Row
) # Dash Body
)# Dash Page
# Create server function (response to UI)----
server <- function(input, output, session){
load("riverdata.rdata")
site_choices <-reactive({
return(subset(river.data, Station == input$site_choices))
})
observeEvent(site_choices(),{
d.choices <- unique(na.omit(site_choices()$Depth))
updateSelectInput(inputId = "depth", choices = d.choices)
})
depth <- reactive({
req(input$depth)
filter(site_choices(), Depth == input$depth)
})
our.data <- reactive({
return(subset(river.data, (params %in% input$param_choices & Station %in% input$site_choices & Depth %in% input$depth)))
# our.data() %>% filter(Date >= input$date_slider[1] & Date <= input$date_slider[2])
})
output$plot1 <- renderPlot({
ggplot(data = our.data(), mapping = aes(x = Datetime, y = value))+
geom_point(size = 2)+
geom_line()+
theme_minimal()+
scale_y_continuous(name =  our.data$Ylabel,
#limits = c(floor(min(our.data()$value, na.rm = T)),ceiling(max(our.data()$value,na.rm = T))),
breaks = pretty_breaks())+
scale_x_datetime(name = "Date")+
theme(
panel.border = element_rect(color = "black", fill = NA, size = 1),
axis.ticks = element_line(color = "black", size = 1),
axis.text = element_text(size = 15)
)
})
}
## Run app----
shinyApp(ui = ui, server = server)
