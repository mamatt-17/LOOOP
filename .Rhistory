lng = mapframe$long,
lat = mapframe$lat,
popup = paste0(
"Station: ",mapframe$Station, "<br>",
"Depth(s): ",mapframe$U.Depths, "<br>",
"Year(s): ",mapframe$U.Years),
labelOptions = labelOptions(textsize = "15px"))
gc()
gc()
gc()
names(providers)
leaflet() %>%
addProviderTiles(providers$Stadia.StamenTerrain,
options = providerTileOptions(noWrap = TRUE)
) %>% setView(
lng = -76.354,
lat= 43.248,
zoom = 9
) %>% addCircleMarkers(
lng = mapframe$long,
lat = mapframe$lat,
popup = paste0(
"Station: ",mapframe$Station, "<br>",
"Depth(s): ",mapframe$U.Depths, "<br>",
"Year(s): ",mapframe$U.Years),
labelOptions = labelOptions(textsize = "15px"))
install.packages("lubridate")
install.packages("plyr")
install.packages("dplyr")
install.packages("tidyr")
install.packages("stringi")
install.packages("openxlsx")
install.packages("writexl")
# Set working directory and load packages----
my_packages <- c("lubridate", "plyr", "dplyr","tidyr", "stringi")
lapply(my_packages, require, character.only = TRUE)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
# Read in csv files of each dataset----
# 3 Rivers data, read all files into 1 dataset----
filenames <- list.files(path = './CSV_files/3Rivers', pattern = '*', full.names = TRUE)
b <- ldply(filenames, read.csv)
rm(b)
# 3 Rivers data, read all files into 1 dataset----
filenames <- list.files(path = './CSV_files/3Rivers', pattern = '*', full.names = TRUE)
b <- ldply(filenames, read.csv)
# Weather Station data, read all files into 1 dataset----
filenames <- list.files(path = './CSV_files/WeatherStations', pattern = '*', full.names = TRUE)
w <- ldply(filenames, read.csv)
# Stream Survey data, read in CSV----
s <- read.csv(file = './CSV_files/StreamData.csv')
# Stream level data, read all files into 1 dataset----
filenames <- list.files(path = './CSV_files/StreamLevels', pattern = '*', full.names = TRUE)
l <- ldply(filenames, read.csv)
View(l)
# Stream Survey data, read in CSV----
s <- read.csv(file = './CSV_files/StreamData.csv')
# STREAM SURVEY DATA----
# Restructure dataframe----
s$Group <- as.factor(as.character(s$Group))
s$Site.Name <- as.factor(as.character(s$Site.Name))
s$Location <- as.factor(as.character(s$Location))
s$Date <- as.Date(s$Date,format = "%m/%d/%Y")
s$Datetime <- as.POSIXct(paste(s$Date, s$Time), format = "%Y-%m-%d %H:%M")
s$Datetime <- round_date(s$Datetime, "1 hour")
s <- s %>% select(!c(Date, Time)) %>% relocate(Datetime, .after = Longitude)
s$Water.Temperature <- as.numeric(as.character(s$Water.Temperature))
s$Air.Temperature <-as.numeric(as.character(s$Air.Temperature))
s$Nitrite <- as.numeric(as.character(s$Nitrite))
s$Nitrate <- as.numeric(as.character(s$Nitrate))
s$Alkalinity <- as.numeric(as.character(s$Alkalinity))
s$pH <- as.numeric(as.character(s$pH))
s$Dissolved.Oxygen <- as.numeric(as.character(s$Dissolved.Oxygen))
s$Chloride <- as.numeric(as.character(s$Chloride))
s$Turbidity <- as.numeric(as.character(s$Turbidity))
s$Biological.Index <-as.numeric(as.character(s$Biological.Index))
# Rename Parameter columns----
s <- s %>% rename(., 'Water Temperature (deg. C)' = Water.Temperature, 'Air Temperature (deg. C)' = Air.Temperature, 'Stream Width (ft)' = Stream.Width,
'Average Stream Depth (ft)' = Avg.Stream.Depth, 'Stream Area (square ft)' = Stream.Area, 'Average Stream Velocity (ft/s)' = Avg.Stream.Velocity,
'Streamflow (cubic ft/s)' = Streamflow, 'Nitrite (mg/L)' = Nitrite, 'Nitrate (mg/L)' = Nitrate, 'Alkalinity (mg/L)' = Alkalinity, 'pH (units)' = pH,
'Dissolved Oxygen (mg/L)' = Dissolved.Oxygen, 'Phosphate (mg/L)' = Phosphate, 'Chloride (mg/L)' = Chloride, 'Turbidity (cm)' = Turbidity,
'Macroinvertebrates Present' = Macroinvertebrates, 'Biological Index Score' = Biological.Index)
# Reshape to long format with a parameters column----
s.long <- s %>% pivot_longer(!c(Group, Site.Name, Location ,Latitude, Longitude, Datetime, 'Macroinvertebrates Present'),
names_to = "params", values_to = "Result")
View(s.long)
#save(b5, mapframe, file = "looop.rdata")
#write.csv(river.data, file = "river_data.csv")
#save(river.data, file = "riverdata.rdata")
#save(mapframe, file = "mapframe.rdata")
save(s.long, w.long, file = "student.rdata")
# WEATHER STATION DATA----
# Restructure dataframe----
w$Group <- as.factor(as.character(w$Group))
w$Site.Name <-as.factor(as.character(w$Site.Name))
w$Date <- as.Date(w$Date,format = "%m/%d/%Y")
w$WindDirection <- as.factor(as.character(w$WindDirection))
# Round Times to the nearest quarter hour and make new dataframe with just hourly data for app----
w$Datetime <- as.POSIXct(paste(w$Date, w$Time), format = "%Y-%m-%d %H:%M:%S")
w$Datetime <- round_date(w$Datetime, "15 minutes")
w <- w %>% select(!c(Date, Time))
# Rename Parameter columns----
w <- w %>% rename(., 'Rain (mm)' = Rain.mm, 'Temperature (deg. C)' = Temp, 'Relative Humidity (%)' = RH,
'Wind Speed (m/s)' = WindSpeed.ms, 'Gust Speed (m/s)' = GustSpeed.ms,
'Wind Direction (theta)' = WindDirection.theta, 'Wind Direction' = WindDirection)
# Reshape to long format with a parameters column----
w.long <- w %>% pivot_longer(!c(Group, Site.Name, Latitude, Longitude, Datetime, 'Wind Direction'),
names_to = "params", values_to = "Result")
# Create hourly dataframe for app----
w.long <- w.long %>% group_by(Datetime = round_date(Datetime, 'hour'), Group, Site.Name, Latitude, Longitude, params) %>%
summarise(Result = round(mean(Result, na.rm = T), 2)) %>% ungroup()
# Pull out hourly wind theta to recalculate average wind direction and append to dataframe----
windtheta <- w.long %>% filter(params == "Wind Direction (theta)")
windtheta <- windtheta %>% mutate(winddir = round(1+(Result)/45, 0)) %>%
mutate('Wind Direction' = lapply(winddir,
function(y)
if (y == 1)
"North" else
if (y == 2)
"North-East" else
if (y == 3)
"East" else
if (y == 4)
"South-East" else
if (y == 5)
"South" else
if (y == 6)
"South-West" else
if (y == 7)
"West" else
if (y == 8)
"North-West" else
if (y == 9)
"North"
)) %>% select(c(Datetime, Group, Site.Name, Latitude, Longitude, 'Wind Direction'))
# Add Summarized Wind Direction back to hourly dataframe
w.long <- w.long %>% left_join(windtheta) %>% relocate('Wind Direction', .after = Longitude)
rm(windtheta)
#save(b5, mapframe, file = "looop.rdata")
#write.csv(river.data, file = "river_data.csv")
#save(river.data, file = "riverdata.rdata")
#save(mapframe, file = "mapframe.rdata")
save(s.long, w.long, file = "student.rdata")
library(shiny)
library(shinydashboard)
library(shinydashboardPlus)
library(rsconnect)
library(leaflet)
library(rstudioapi)
library(shinycssloaders)
library(rmarkdown)
library(markdown)
library(lubridate)
library(plyr)
library(dplyr)
library(tidyr)
library(ggplot2)
library(knitr)
library(scales)
library(htmltools)
library(fontawesome)
library(DT)
# Create User Interface (UI)----
ui <- navbarPage(title =  a("LOOOP", href = "https://sites.google.com/view/looop-ufi/", style = "color:gray;"),
header = (includeHTML(("google-analytics.html"))),
tabPanel("Data Explorer",
fluidRow(
box(uiOutput("plotui")),
box(title = "Controls",
selectInput("data_type", "Monitoring Type:", choices = list('Stream Survey' = "s", 'Weather Station' = "w"), selected = "w"),
selectInput("site_choices", "Site:", choices = NULL),
selectInput("param_choices","Parameter:", choices = NULL),
uiOutput("date_slider"))
),
fluidRow(
box(h4("Points within box"),
DT::dataTableOutput("brush_info")
),
box(leaflet::leafletOutput("mymap")
))
),
tabPanel("Explorer Guide",
includeMarkdown("StaticPosts/About-Data.Rmd")
),
tabPanel("Stream Parameters",
includeMarkdown("StaticPosts/Stream_Descriptions.Rmd")
),
tabPanel("Weather Parameters",
includeMarkdown("StaticPosts/Weather_Descriptions.Rmd")),
tabPanel("Credits/Policies",
includeMarkdown("StaticPosts/Credits-Policies.Rmd")
),
collapsible = TRUE,
position = "static-top")
# Create server function (response to UI)----
server <- function(input, output, session){
showModal(modalDialog(title = "Welcome to the LOOOP!",
"Use the Plot Options to begin exploring data collected by students and youth in Central New York.
Click outside of this box and select a dropdown option to get started!",
size = "l",
easyClose = T,
footer = NULL))
load("student.rdata")
# Create reactive control box options based on selected dataset (stream surveys or weather station)
datasetInput <- reactive({
if(input$data_type == "s"){
selected.dataset <- s.long
}
else if(input$data_type == "w"){
selected.dataset <- w.long
}
return(selected.dataset)
})
# Using reactive dataset element, update dropdown choices for sites and parameters
observeEvent(datasetInput(),{
s.choices <- unique(na.omit(datasetInput()$Site.Name))
updateSelectInput(session,inputId = "site_choices", "Site:", choices = s.choices, selected = NULL)
})
observeEvent(datasetInput(),{
p.choices <- unique(na.omit(datasetInput()$params))
updateSelectInput(session, inputId = "param_choices", "Parameter:", choices = p.choices, selected = NULL)
})
# Using reactive dataset, update date range to min and max of dataset and filtered site
output$date_slider <- renderUI({
req(input$site_choices)
date_min= min(datasetInput()$Datetime[datasetInput()$Site.Name == input$site_choices])
date_max = max(datasetInput()$Datetime[datasetInput()$Site.Name == input$site_choices])
sliderInput("date_slider","Date Range:", min = date_min, max = date_max, value = c(date_min,date_max), step = 3600, timezone = "EST")
})
# Create a reactive dataframe that subsets the selected dataset based on selected choices for graphing
our.data <- reactive({
if(input$data_type == "s"){
return(subset(s.long, (params %in% input$param_choices & Site.Name %in% input$site_choices
& Datetime >= input$date_slider[1] & Datetime <= input$date_slider[2])))
}
else if(input$data_type == "w"){
return(subset(w.long, (params %in% input$param_choices & Site.Name %in% input$site_choices
& Datetime >= input$date_slider[1] & Datetime <= input$date_slider[2])))
}
})
# Create interactive plot
output$plotui <-
renderUI({
plotOutput("plot", height = 350,
brush = brushOpts(
id = "plot_brush"
))
})
# Make reactive elements for plotting purposes
plottinginfo <- reactive({
if(input$data_type == "s"){
majorbreaks <- "day"
minorbreaks <- "day"
datelabels <- "%b %d"
}
else if(input$data_type == "w"){
majorbreaks <- "day"
minorbreaks <- "1 hour"
datelabels <- "%b %d"
}
return(data.frame(majorbreaks, minorbreaks, datelabels))
})
# Plotting framework
output$plot <- renderPlot({
ggplot(data = our.data(), mapping = aes(x = Datetime, y = Result))+
geom_point(size = 2)+
geom_line()+
theme_minimal()+
labs(x = "Date", y = input$param_choices)+
scale_x_datetime(limits = c(input$date_slider[1],input$date_slider[2]),
breaks = plottinginfo()$majorbreaks,
minor_breaks = plottinginfo()$minorbreaks,
labels = date_format(plottinginfo()$datelabels, tz = "America/New_York")
)+
theme(
panel.border = element_rect(color = "black", fill = NA, linewidth = 1),
axis.ticks = element_line(color = "black", linewidth = 1),
axis.text = element_text(size = 15)
)
})
# Make reactive elements for brush table
tableinfo <- reactive({
if(input$data_type == "s"){
selectedinfo <- 'Macroinvertebrates Present'
}
else if(input$data_type == "w"){
selectedinfo <- "Wind Direction"
return(selectedinfo)
}
})
# Make data table that contains information related to what is boxed in plot
output$brush_info <- DT::renderDataTable({
res <- brushedPoints(our.data() %>% select(., c(Datetime, Group, Latitude, Longitude, tableinfo(), Result)), input$plot_brush)
datatable(res)
})
# Making the map
mymap <- createLeafletMap(session,"mymap")
output$mymap <- renderLeaflet({
leaflet() %>%
addProviderTiles(providers$Stadia.StamenTerrain,
options = providerTileOptions(noWrap = TRUE)
) %>% setView(
lng = -76.176684,
lat= 43.082970,
zoom = 10
) %>% addCircleMarkers(
lng = s.long$Longitude,
lat = s.long$Latitude,
color = "blue",
popup = paste0(
"Location: ",s.long$Location, "<br>",
"Latest Monitoring Date: ", format(s.long$Datetime, "%m/%d/%Y"), "<br>",
"Group(s): ",s.long$Group),
labelOptions = labelOptions(textsize = "15px")
) %>% addCircleMarkers(
lng = w.long$Longitude,
lat = w.long$Latitude,
color = "red",
popup = paste0(
"Location: ",w.long$Site.Name, "<br>",
"Latest Monitoring Date: ", format(w.long$Datetime, "%m/%d/%Y"), "<br>",
"Group(s): ",w.long$Group),
labelOptions = labelOptions(textsize = "15px")
)
})
## Run app----
shinyApp(ui = ui, server = server)
# Load packages----
library(shiny)
library(shinydashboard)
library(shinydashboardPlus)
library(rsconnect)
library(leaflet)
library(rstudioapi)
library(shinycssloaders)
library(rmarkdown)
library(markdown)
library(lubridate)
library(plyr)
library(dplyr)
library(tidyr)
library(ggplot2)
library(knitr)
library(scales)
library(htmltools)
library(fontawesome)
library(DT)
# Create User Interface (UI)----
ui <- navbarPage(title =  a("LOOOP", href = "https://sites.google.com/view/looop-ufi/", style = "color:gray;"),
header = (includeHTML(("google-analytics.html"))),
tabPanel("Data Explorer",
fluidRow(
box(uiOutput("plotui")),
box(title = "Controls",
selectInput("data_type", "Monitoring Type:", choices = list('Stream Survey' = "s", 'Weather Station' = "w"), selected = "w"),
selectInput("site_choices", "Site:", choices = NULL),
selectInput("param_choices","Parameter:", choices = NULL),
uiOutput("date_slider"))
),
fluidRow(
box(h4("Points within box"),
DT::dataTableOutput("brush_info")
),
box(leaflet::leafletOutput("mymap")
))
),
tabPanel("Explorer Guide",
includeMarkdown("StaticPosts/About-Data.Rmd")
),
tabPanel("Stream Parameters",
includeMarkdown("StaticPosts/Stream_Descriptions.Rmd")
),
tabPanel("Weather Parameters",
includeMarkdown("StaticPosts/Weather_Descriptions.Rmd")),
tabPanel("Credits/Policies",
includeMarkdown("StaticPosts/Credits-Policies.Rmd")
),
collapsible = TRUE,
position = "static-top")
# Create server function (response to UI)----
server <- function(input, output, session){
showModal(modalDialog(title = "Welcome to the LOOOP!",
"Use the Plot Options to begin exploring data collected by students and youth in Central New York.
Click outside of this box and select a dropdown option to get started!",
size = "l",
easyClose = T,
footer = NULL))
load("student.rdata")
# Create reactive control box options based on selected dataset (stream surveys or weather station)
datasetInput <- reactive({
if(input$data_type == "s"){
selected.dataset <- s.long
}
else if(input$data_type == "w"){
selected.dataset <- w.long
}
return(selected.dataset)
})
# Using reactive dataset element, update dropdown choices for sites and parameters
observeEvent(datasetInput(),{
s.choices <- unique(na.omit(datasetInput()$Site.Name))
updateSelectInput(session,inputId = "site_choices", "Site:", choices = s.choices, selected = NULL)
})
observeEvent(datasetInput(),{
p.choices <- unique(na.omit(datasetInput()$params))
updateSelectInput(session, inputId = "param_choices", "Parameter:", choices = p.choices, selected = NULL)
})
# Using reactive dataset, update date range to min and max of dataset and filtered site
output$date_slider <- renderUI({
req(input$site_choices)
date_min= min(datasetInput()$Datetime[datasetInput()$Site.Name == input$site_choices])
date_max = max(datasetInput()$Datetime[datasetInput()$Site.Name == input$site_choices])
sliderInput("date_slider","Date Range:", min = date_min, max = date_max, value = c(date_min,date_max), step = 3600, timezone = "EST")
})
# Create a reactive dataframe that subsets the selected dataset based on selected choices for graphing
our.data <- reactive({
if(input$data_type == "s"){
return(subset(s.long, (params %in% input$param_choices & Site.Name %in% input$site_choices
& Datetime >= input$date_slider[1] & Datetime <= input$date_slider[2])))
}
else if(input$data_type == "w"){
return(subset(w.long, (params %in% input$param_choices & Site.Name %in% input$site_choices
& Datetime >= input$date_slider[1] & Datetime <= input$date_slider[2])))
}
})
# Create interactive plot
output$plotui <-
renderUI({
plotOutput("plot", height = 350,
brush = brushOpts(
id = "plot_brush"
))
})
# Make reactive elements for plotting purposes
plottinginfo <- reactive({
if(input$data_type == "s"){
majorbreaks <- "day"
minorbreaks <- "day"
datelabels <- "%b %d"
}
else if(input$data_type == "w"){
majorbreaks <- "day"
minorbreaks <- "1 hour"
datelabels <- "%b %d"
}
return(data.frame(majorbreaks, minorbreaks, datelabels))
})
# Plotting framework
output$plot <- renderPlot({
ggplot(data = our.data(), mapping = aes(x = Datetime, y = Result))+
geom_point(size = 2)+
geom_line()+
theme_minimal()+
labs(x = "Date", y = input$param_choices)+
scale_x_datetime(limits = c(input$date_slider[1],input$date_slider[2]),
breaks = plottinginfo()$majorbreaks,
minor_breaks = plottinginfo()$minorbreaks,
labels = date_format(plottinginfo()$datelabels, tz = "America/New_York")
)+
theme(
panel.border = element_rect(color = "black", fill = NA, linewidth = 1),
axis.ticks = element_line(color = "black", linewidth = 1),
axis.text = element_text(size = 15)
)
})
# Make reactive elements for brush table
tableinfo <- reactive({
if(input$data_type == "s"){
selectedinfo <- 'Macroinvertebrates Present'
}
else if(input$data_type == "w"){
selectedinfo <- "Wind Direction"
return(selectedinfo)
}
})
# Make data table that contains information related to what is boxed in plot
output$brush_info <- DT::renderDataTable({
res <- brushedPoints(our.data() %>% select(., c(Datetime, Group, Latitude, Longitude, tableinfo(), Result)), input$plot_brush)
datatable(res)
})
# Making the map
mymap <- createLeafletMap(session,"mymap")
output$mymap <- renderLeaflet({
leaflet() %>%
addProviderTiles(providers$Stadia.StamenTerrain,
options = providerTileOptions(noWrap = TRUE)
) %>% setView(
lng = -76.176684,
lat= 43.082970,
zoom = 10
) %>% addCircleMarkers(
lng = s.long$Longitude,
lat = s.long$Latitude,
color = "blue",
popup = paste0(
"Location: ",s.long$Location, "<br>",
"Latest Monitoring Date: ", format(s.long$Datetime, "%m/%d/%Y"), "<br>",
"Group(s): ",s.long$Group),
labelOptions = labelOptions(textsize = "15px")
) %>% addCircleMarkers(
lng = w.long$Longitude,
lat = w.long$Latitude,
color = "red",
popup = paste0(
"Location: ",w.long$Site.Name, "<br>",
"Latest Monitoring Date: ", format(w.long$Datetime, "%m/%d/%Y"), "<br>",
"Group(s): ",w.long$Group),
labelOptions = labelOptions(textsize = "15px")
)
})
}
## Run app----
shinyApp(ui = ui, server = server)
